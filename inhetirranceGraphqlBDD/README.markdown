## "Système d'héritage" en BDD et exposition en GraphQL

J'ai exploré la possibilité d'héritage en BDD grâce à Hibernate. Cet
[article](https://www.baeldung.com/hibernate-inheritance) est intéressant à ce sujet.

### Single Table

J'ai choisi la stratégie `Single Table` pour l'héritage. Cela permet de stocker toutes les données dans une seule table.
Cela permet de simplifier les requêtes et de ne pas avoir à faire de jointures. La table porte une colonne `type` qui
permet de savoir de quel type d'objet il s'agit. C'est une chaîne de caractères qui correspond au nom de la classe.
Les attributs des classes filles sont stockés dans des colonnes `nullable` de la table.

Par exemple, pour l'insertion de stylo :

```sql
insert
into product
    (name, color, dtype, product_id)
values (?, ?, 'Pen', default)
```

Pour la récupération de stylo :

```sql
 select p1_0.product_id,
        p1_0.name,
        p1_0.color
 from product p1_0
 where p1_0.dtype = 'Pen'
   and p1_0.product_id = ?
```

### Join Table

Une autre stratégie possible est `Join Table`. Cela permet de stocker les attributs des classes filles dans une table
à part. Cela permet de ne pas avoir de colonnes `nullable` dans la table principale et de ne pas à avoir
à modifier la table principale si on ajoute une classe fille. La table fille est liée à la table mère par une
clé étrangère. Cela permet de faire des jointures pour récupérer les données.

Création des tables

```sql
create table pen
(
    product_id bigint not null,
    color      varchar(255),
    primary key (product_id)
);

create table product
(
    product_id bigint generated by default as identity,
    name       varchar(255),
    primary key (product_id)
);

alter table if exists pen
    add constraint FKfl5aq7hrd606geb6nh1vrep88
    foreign key (product_id)
    references product
```

Par exemple, pour l'insertion de stylo :

```sql
-- table product
insert
into product
    (name, product_id)
values (?, default)

-- table pen
    insert
into
    pen
    (color, product_id)
values
    (?, ?)
```

Pour la récupération de stylo :

```sql
select p1_0.product_id,
       p1_1.name,
       p1_0.color
from pen p1_0
         join
     product p1_1
     on p1_0.product_id = p1_1.product_id
where p1_0.product_id = ?
```

### Conclusion

_Fournie par ChatGPT via le modèle GPT4 après lui avoir demandé le pour et le contre par rapport à ce que j'ai dit 
précedemment_

#### Single Table

##### Avantages

Les requêtes sont généralement plus rapides car il n'y a pas besoin de jointures pour récupérer les données.
C'est particulièrement utile si vous accédez souvent à des données polymorphiques (c'est-à-dire à des données qui
pourraient être de n'importe quel type dans la hiérarchie d'héritage). De plus, cela peut simplifier vos requêtes SQL et
rendre votre code plus facile à comprendre.

##### Inconvénients

Si vous avez de nombreuses sous-classes avec de nombreux attributs spécifiques à chaque sous-classe,
vous pouvez vous retrouver avec une table avec un grand nombre de colonnes, beaucoup d'entre elles étant vides (null)
pour de nombreuses lignes. Cela peut entraîner une utilisation inefficace de l'espace de stockage. De plus, si vous
ajoutez souvent de nouvelles sous-classes, vous devez modifier la structure de la table chaque fois, ce qui peut être
une opération coûteuse.

#### Join Table

##### Avantages

C'est une manière plus naturelle et plus flexible de modéliser l'héritage, qui correspond plus étroitement à
la manière dont l'héritage fonctionne dans la plupart des langages de programmation orientés objet. Cela peut rendre
votre code plus facile à comprendre et à maintenir. De plus, chaque sous-classe a sa propre table, donc vous n'avez pas
de colonnes vides inutiles et l'ajout de nouvelles sous-classes ne nécessite pas de modification de la structure de la
table parent.

##### Inconvénients

Les requêtes peuvent être plus lentes car vous devez effectuer des jointures pour accéder aux données.
C'est particulièrement vrai si vous accédez souvent à des données polymorphiques. De plus, si vous avez de nombreuses
sous-classes et que vous devez souvent accéder à des données à travers plusieurs sous-classes, vous pouvez vous
retrouver à devoir gérer des requêtes complexes avec de multiples jointures, ce qui peut ralentir les performances et
rendre votre code plus difficile à comprendre.